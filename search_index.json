[["index.html", "OCA Data Sharing Practicals Chapter 1 Introduction 1.1 Setup", " OCA Data Sharing Practicals Chapter 1 Introduction This repository contains two training documents for the OCA Data Sharing Platform: Chapter 2: Data dictionaries covers the production of data dictionaries to accompany datasets that will be shared Chapter 3: Pseudonymization covers techniques for assessing and limiting disclosure risk when preparing datasets to be share 1.1 Setup Before moving on to Chapter 2, setup a folder on your computer where you can store the datasets that accompany this practical. If you use R Studio we suggest setting up a new R Project, as described in The Epidemiologist R Handbook. The datasets used in Chapters 2 and 3 can be downloaded from GitHub via the links below. Our example code chunks in Chapters 2 and 3 assume that these datasets will be stored within a folder called “data/”. mortality_survey_simple_kobo.xlsx mortality_survey_simple_data.xlsx mortality_survey_simple_dict_pre_pseudonym.xlsx You will also need to install some R packages. install.packages(c(&quot;remotes&quot;, &quot;rio&quot;, &quot;here&quot;)) remotes::install_github(&quot;epicentre-msf/datadict&quot;) "],["data-dict.html", "Chapter 2 Data dictionaries 2.1 Objectives 2.2 Background 2.3 Dictionary format 2.4 The datadict package 2.5 Exercises", " Chapter 2 Data dictionaries 2.1 Objectives Learn to: prepare an OCA-style data dictionary, starting from either a raw dataset or a ODK/Kobo dictionary compare datasets and corresponding data dictionaries to ensure completeness and validity 2.2 Background Documenting the variables in a dataset is a crucial part of data management and ensures that a dataset is interpretable by researchers who were not directly involved in study design or data collection. Whereas data files will generally contain codenames for variables (e.g. patagegrp for “Patient’s age group”), and sometimes also coded data values, the data dictionary describes each variable and the set of possible values in plain language that is more broadly interpretable. Data collection platforms such as Kobo, REDCap, and OpenClinica have their own specialized data dictionary format. To facilitate dataset and data dictionary validation, the OCA Data Sharing Platform uses its own standardized dictionary format, defined in the next section. 2.3 Dictionary format Every dataset shared or archived on the OCA platform must have an accompanying data dictionary that includes, at a minimum, the fields described below. Each variable in the dataset (i.e. each column) must have a dictionary entry for each of the required fields. Required field Description Example entry variable_name Variable name (i.e. exact column name within the corresponding dataset) “sample_type” short_label Short phrase describing the variable in words “Type of laboratory sample collected” type Variable type (options: “Numeric”, “Date”, “Time”, “Datetime”, “Coded list”, or “Free text”) “Coded list” choices The list of options (pairs of codes and labels) corresponding to a variable of type “Coded list”. “1, Blood | 2, Nasal swab | 3, Throat swab | 4, Other” origin Was the variable a part of the original data collection instrument (option “original”), or was it later derived (option “derived”) “original” status Is the variable shared (option “shared”), or withheld to reduce disclosure risk (option “withheld”) ? “shared” 2.4 The datadict package The R package datadict contains a variety of functions to aid in the preparation of an OCA-style data dictionary: dict_from_data(): prepare a dictionary template from a raw dataset dict_from_odk(): prepare a dictionary template from an ODK/Kobo dictionary dict_from_redcap(): prepare a dictionary template from a REDCap dictionary valid_dict(): verify that a dictionary is consistent with the OCA format valid_data(): verify that a dataset corresponds to its associated data dictionary Note that dictionary templates produces by the dict_from_ functions may still require further processing by the user (e.g. with additional R scripts, or by hand in Excel). 2.5 Exercises This repository includes an example dataset based on a mortality survey, and corresponding ODK data dictionary (see section 1.1 Setup for data download links). Load the dataset and data dictionary using the example code below (note you may need to modify the file path, depending on how you setup your project), and work through the following exercises using functions from the datadict package where possible. library(rio) library(here) # import dataset dat &lt;- rio::import(here(&quot;data/mortality_survey_simple_data.xlsx&quot;), setclass = &quot;tbl&quot;) # import ODK dictionary (note the main dictionary and multiple-choice options are in separate sheets) odk_survey &lt;- rio::import(here(&quot;data/mortality_survey_simple_kobo.xlsx&quot;), sheet = &quot;survey&quot;, setclass = &quot;tbl&quot;) odk_choices &lt;- rio::import(here(&quot;data/mortality_survey_simple_kobo.xlsx&quot;), sheet = &quot;choices&quot;, setclass = &quot;tbl&quot;) 2.5.1 Exercise 1 With the datadict package we can prepare a dictionary template either from the raw dataset (using function dict_from_data()) or from the ODK dictionary (using function dict_from_odk()). Try both approaches separately and compare the resulting dictionary templates. What are some differences? Can you guess why these differences are occurring? See proposed answer dict_dat &lt;- datadict::dict_from_data(dat) dict_odk &lt;- datadict::dict_from_odk(odk_survey, odk_choices) if (!dir.exists(here(&quot;output&quot;))) dir.create(here(&quot;output&quot;)) rio::export(dict_dat, here(&quot;output/ex1_dict_dat.xlsx&quot;)) rio::export(dict_odk, here(&quot;output/ex1_dict_odk.xlsx&quot;)) Function dict_from_data() doesn’t populate column short_label, whereas dict_from_odk() does Variable types in column type are different. Function dict_from_data() guesses only ‘Free text’ and ‘Coded list’, whereas dict_from_odk() also returns ‘Date’ and ‘Numeric’ 2.5.2 Exercise 2 When producing a dictionary template using dict_from_data(), the variable type is determined by the class of the original column (e.g. character, numeric, Date). The column classes that are read in by e.g. rio::import() might not always correspond to the variable types that we have in mind (e.g. numbers, dates, and times are sometimes read in as class “character”). Where necessary, transform the columns of dat using functions like as.numeric() or as.Date() and then produce another dictionary template using dict_from_data(). What are the differences that remain between this dictionary template and the template derived from the ODK dictionary? See proposed answer vars_date &lt;- c( &quot;date&quot;, &quot;date_arrived&quot;, &quot;date_departed&quot;, &quot;date_born&quot;, &quot;date_died&quot; ) vars_numeric &lt;- c( &quot;cluster&quot;, &quot;age_months&quot;, &quot;age_years&quot;, &quot;muac&quot; ) for (j in vars_date) { dat[[j]] &lt;- as.Date(dat[[j]]) } for (j in vars_numeric) { dat[[j]] &lt;- as.numeric(dat[[j]]) } dict_dat &lt;- datadict::dict_from_data(dat) rio::export(dict_dat, here(&quot;output/ex2_dict_dat.xlsx&quot;)) Function dict_from_data() classifies some variables as “Coded list” that dict_from_odk() classifies as “Free text” (source_water_other, ilness_other, cause_death_other) Various differences in column choices (order varies, some entries missing with dict_from_data(), labels same but values differ) Function dict_from_odk() retains extra columns from ODK data dictionary (e.g. constrain, relevant, etc.) 2.5.3 Exercise 3 Examine the options for the ‘Coded list’ type variables in the dictionary produced in exercise 2, and compare these to the corresponding options produced by dict_from_odk(). Why does the dictionary produced by dict_from_data() have fewer ‘Coded list’ options for some variables? Does this matter in terms of data sharing? Hint: check out the function datadict::coded_options() to extract a long-form table of Coded list variables and corresponding options from a dictionary. See proposed answer opts_dat &lt;- datadict::coded_options(dict_dat) opts_odk &lt;- datadict::coded_options(dict_odk) rio::export(opts_dat, here(&quot;output/ex3_opts_dat.xlsx&quot;)) rio::export(opts_odk, here(&quot;output/ex3_opts_odk.xlsx&quot;)) Function dict_from_data() only includes options that appear in the dataset, whereas dict_from_odk() includes all options from original ODK dictionary 2.5.4 Exercise 4 Use the function valid_dict() to check that the dictionary you produced in Exercise 2 complies with the OCA standard. Assuming it does, edit the dictionary so that it fails at least two of the checks implemented by valid_dict(). See proposed answer datadict::valid_dict(dict_dat) ## [1] TRUE dict_dat_fail1 &lt;- dict_dat dict_dat_fail1$variable_name[4] &lt;- NA_character_ datadict::valid_dict(dict_dat_fail1) ## Warning: - Missing values in column(s): &quot;variable_name&quot; ## [1] FALSE dict_dat_fail2 &lt;- dict_dat dict_dat_fail2$type &lt;- &quot;Number&quot; datadict::valid_dict(dict_dat_fail2) ## Warning: - Column `type` has nonvalid value(s): &quot;number&quot; ## [1] FALSE 2.5.5 Exercise 5 Use the function valid_data() to check for consistency between the dataset and dictionary produced in Exercise 2. Assuming all checks pass, edit the dataset so that it fails at least two of the checks implemented by valid_data(). See proposed answer datadict::valid_data(dat, dict_dat) ## [1] TRUE # add nonvalid date dat$date &lt;- as.character(dat$date) dat$date[4] &lt;- &quot;July ?, 2021&quot; # remove column present in dictionary dat$oedema &lt;- NULL datadict::valid_data(dat, dict_dat) ## Warning: - Columns defined in `dict` but not present in `data`: &quot;oedema&quot; ## - Variables of type &#39;Date&#39; contain nonvalid values: &quot;date&quot; ## [1] FALSE "],["pseudonym.html", "Chapter 3 Pseudonymization 3.1 Objectives 3.2 Background 3.3 Typical workflow 3.4 Exercise", " Chapter 3 Pseudonymization 3.1 Objectives Learn to: assess the variables in a dataset for disclosure risk and utility implement pseudonymization procedures, where necessary, to limit disclosure risk ensure that a final dataset meets all data-sharing requirements 3.2 Background 3.2.1 Disclosure When a person or organization recognizes or learns something that they did not already know about another identifiable person or organization through released data. This might occur through: spontaneous recognition (i.e. someone with knowledge of the sampled population recognizes a unique or particular combination of data values) record matching/linkage with other existing datasets (e.g. population registers, electoral rolls, data from specialized firms) 3.2.2 Identifiers Direct identifiers: variables that unambiguously reveal a person’s identity (e.g. name, passport number, phone number, physical address, email address) Indirect identifiers: variables that contain information that, when combined with other variables, could lead to re-identification (e.g. sex, age, marital status, occupation). Note potential for elevated identifiability risk from extreme values of continuous variables (height, income, number of children, land area). 3.2.3 k-anonymity A measure of re-identification risk for discrete variables. k = the number of records in a dataset containing a certain combination of indirect identifiers (e.g. how many records with sex = “male” and age_group = “40-49 years” ?). Higher value of k means lower re-identification risk, because higher k means more records in the dataset with the same combination of indirect identifiers. 3.2.4 Pseudonymization Methods used to transform a dataset to achieve an “acceptable level” of re-identification / disclosure risk. Two types of methods: Non-perturbative: suppression (remove entire variables, or specific records or values) or aggregation (aggregate levels of a variable to reduce uniqueness) Perturbative: shuffle values or add noise to a variable while preserving desired statistical properties 3.3 Typical workflow Select a threshold value of k-anonymity that will be the minimum acceptable value for combinations of indirect identifiers within the released dataset (e.g. k = 5). Assess re-identification risk of each variable (e.g. direct identifier, indirect identifier, non-identifying). Assess utility of each variable for analysis (e.g. high, low, uncertain). Withhold variables classified as direct identifiers (e.g. name, phone number, address). Consider withholding other variables with low utility and non-zero re-identification risk. Merge groups of related indirect identifiers, where possible. E.g. If dataset contains two age-related variables age_in_years and age_in_months, merge these two variables into a new derived variable age, and withhold the original variables. Review all unique values of ‘free-text’ type variables to ensure they do not contain identifying details. Aggregate or withhold as necessary. Discretise any indirect identifiers that are continuous variables (e.g. height in cm -&gt; discrete height categories). Assess re-identification risk criterion (i.e. k-anonymity) using all indirect identifiers. Pseudonymize indirect identifiers to limit re-identification risk (e.g. aggregate, withhold). Repeat steps 8 and 9 until the given risk criterion is met. Ensure that the final pseudonymized dataset and dictionary meet all data-sharing requirements. 3.4 Exercise This repository includes an example dataset based on a mortality survey (see section 1.1 Setup for data download links). Load the dataset and pre-prepared data dictionary using the example code below, and use them to work through the pseudonymization workflow described above. library(rio) library(here) # import dataset and prepared data dictionary dat &lt;- rio::import(here(&quot;data/mortality_survey_simple_data.xlsx&quot;), setclass = &quot;tbl&quot;) dict &lt;- rio::import(here(&quot;data/mortality_survey_simple_dict_pre_pseudonym.xlsx&quot;), setclass = &quot;tbl&quot;) As you make your way through the pseudonymization workflow, answer the following questions: (1) Which variables, if any, did you assess as either direct or indirect identifiers? (2) Despite not being completely familiar with the original study, were you able to assess any variables as being of low utility for analysis? If so, what actions did you take? (3) Did you find any groups of related variables that you decided to merge into a new derived variable? (4) In your assessment of free-text variables, did you notice any values that were potentially identifying? If so, what actions did you take? (5) In your initial application of Step 6 of the pseudonymization work flow, were there any combinations of indirect identifiers yielding values of k below your pre-selected threshold? If so, what action did you take? See proposed workflow Load required packages and read data/dictionary # ensures the package &quot;pacman&quot; is installed if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) # load/install packages from CRAN pacman::p_load( # project and file management here, # file paths relative to R project root folder rio, # import/export of many types of data # general data management dplyr # data wrangling ) # Load/install packages from GitHub pacman::p_load_gh( # data dictionary &quot;epicentre-msf/datadict&quot; # create/validate data dictionary ) # read/prep dictionary odk_survey &lt;- rio::import(here(&quot;data/mortality_survey_simple_kobo.xlsx&quot;), sheet = &quot;survey&quot;, setclass = &quot;tbl&quot;) odk_choices &lt;- rio::import(here(&quot;data/mortality_survey_simple_kobo.xlsx&quot;), sheet = &quot;choices&quot;, setclass = &quot;tbl&quot;) dict &lt;- datadict::dict_from_odk(odk_survey, odk_choices) # read dataset (and reclass columns according to dictionary) dat &lt;- rio::import(here(&quot;data/mortality_survey_simple_data.xlsx&quot;), setclass = &quot;tbl&quot;) %&gt;% datadict::reclass_data(dict) 3.4.0.1 Select a threshold value of k-anonymity k = 5 3.4.0.2 Assess re-identification risk of each variable (e.g. direct identifier, indirect identifier, non-identifying). Indirect identifiers: location source_water sex age_under_one age_months age_years arrived date_arrived departed date_departed born date_born 3.4.0.3 Assess utility of each variable for analysis (e.g. high, low, uncertain). Most variables of ‘high’ utility for analysis 3.4.0.4 Withhold variables classified as direct identifiers. Consider withholding other variables with low utility and non-zero re-identification risk. No direct identifiers 3.4.0.5 Merge groups of related indirect identifiers, where possible. The most obvious group of related variables to merge are the age-related variables, age_under_one, age_months, and age_years. We’ll also merge all of the date variables (except date_death) and related indicators into a single new derived variable exposure, the number of days that a given person was at risk of mortality. ## merge age variables --------------------------------------------------------- age_group_levels &lt;- c(&quot;0-2&quot;, &quot;3-14&quot;, &quot;15-29&quot;, &quot;30-44&quot;, &quot;45+&quot;) dat &lt;- dat %&gt;% mutate( age_group = case_when( age_under_one == &quot;Yes&quot; ~ &quot;0-2&quot;, age_years &lt;= 2 ~ &quot;0-2&quot;, age_years &gt;= 3 &amp; age_years &lt;= 14 ~ &quot;3-14&quot;, age_years &gt;= 15 &amp; age_years &lt;= 29 ~ &quot;15-29&quot;, age_years &gt;= 30 &amp; age_years &lt;= 44 ~ &quot;30-44&quot;, age_years &gt;= 45 ~ &quot;45+&quot; ), .after = age_years, age_group = factor(age_group, levels = age_group_levels) ) # withhold old age variables dat$age_under_one &lt;- NA_character_ dat$age_months &lt;- NA_real_ dat$age_years &lt;- NA_real_ vars_withhold &lt;- c( &quot;age_under_one&quot;, &quot;age_months&quot;, &quot;age_years&quot; ) dict$status[dict$variable_name %in% vars_withhold] &lt;- &quot;withheld&quot; # add new age var to dictionary age_group_choices &lt;- datadict::generate_coded_options(age_group_levels) dict &lt;- dict %&gt;% add_row( variable_name = &quot;age_group&quot;, short_label = &quot;Age group (downscaled from age variables `age_months` and `age_years`)&quot;, type = &quot;Coded list&quot;, choices = age_group_choices, origin = &quot;derived&quot;, status = &quot;shared&quot;, .after = which(.$variable_name == &quot;age_years&quot;) ) ## merge date variables -------------------------------------------------------- dat &lt;- dat %&gt;% mutate( date_min = as.Date(&quot;2020-07-01&quot;) ) %&gt;% mutate( date_start = as.Date(apply(select(., date_min, date_arrived, date_born), 1, max, na.rm = TRUE)), date_end = as.Date(apply(select(., date, date_departed), 1, max, na.rm = TRUE)), exposure = as.integer(date_end - date_start), .after = date_died ) %&gt;% select(-date_min, -date_start, -date_end) # withhold old date variables (and related indicators) dat$born &lt;- NA_character_ dat$date_born &lt;- as.Date(NA_character_) dat$arrived &lt;- NA_character_ dat$date_arrived &lt;- as.Date(NA_character_) dat$departed &lt;- NA_character_ dat$date_departed &lt;- as.Date(NA_character_) vars_withhold &lt;- c( &quot;born&quot;, &quot;date_born&quot;, &quot;arrived&quot;, &quot;date_arrived&quot;, &quot;departed&quot;, &quot;date_departed&quot; ) dict$status[dict$variable_name %in% vars_withhold] &lt;- &quot;withheld&quot; # add new exposure var to dictionary dict &lt;- dict %&gt;% add_row( variable_name = &quot;exposure&quot;, short_label = &quot;Exposure period in days (derived from study start date &#39;2020-07-01&#39; and variables `date_born`, `date_arrived`, and `date_departed`)&quot;, type = &quot;Numeric&quot;, choices = NA_character_, origin = &quot;derived&quot;, status = &quot;shared&quot;, .after = which(.$variable_name == &quot;date_died&quot;) ) 3.4.0.6 Review all unique values of ‘free-text’ type variables to ensure they do not contain identifying details. Aggregate or withhold as necessary. dict %&gt;% filter(type %in% &quot;Free text&quot;) %&gt;% select(1:3) ## # A tibble: 3 × 3 ## variable_name short_label type ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 source_water_other Please, specify other source of water Free text ## 2 ilness_other If other illness, specify, please Free text ## 3 cause_death_other If other cause of death, specify, please Free text dat %&gt;% count(source_water_other) ## # A tibble: 3 × 2 ## source_water_other n ## &lt;chr&gt; &lt;int&gt; ## 1 Buying purified water 2 ## 2 Untreated water wells 2 ## 3 &lt;NA&gt; 996 dat %&gt;% count(ilness_other) ## # A tibble: 3 × 2 ## ilness_other n ## &lt;chr&gt; &lt;int&gt; ## 1 Diarrhea, fever and rash 1 ## 2 died before 1 ## 3 &lt;NA&gt; 998 dat %&gt;% count(cause_death_other) ## # A tibble: 4 × 2 ## cause_death_other n ## &lt;chr&gt; &lt;int&gt; ## 1 Cancer 1 ## 2 Gunshot 1 ## 3 Stroke 1 ## 4 &lt;NA&gt; 997 Value “Untreated water wells” of variable source_water_other is potentially identifying. We’ll treat it as indirect identifier along with variable source_water. 3.4.0.7 Discretise any indirect identifiers that are continuous variables. None remaining (already discretised the age variables when we merged them) 3.4.0.8 Assess re-identification risk criterion (i.e. k-anonymity) using all indirect identifiers. vars_indirect &lt;- c( &quot;location&quot;, &quot;source_water&quot;, &quot;source_water_other&quot;, &quot;sex&quot;, &quot;age_group&quot; ) datadict::k_anonymity_counts(dat, vars_indirect, threshold = 5) ## # A tibble: 25 × 6 ## location source_water source_water_other sex age_group k ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;int&gt; ## 1 Town A Direct from canal &lt;NA&gt; Fema… 0-2 1 ## 2 Town A Direct from canal &lt;NA&gt; Male 3-14 1 ## 3 Town A Other (specify) Buying purified w… Male 3-14 1 ## 4 Town A Other (specify) Buying purified w… Male 15-29 1 ## 5 Town A Tank filled by a truck tra… &lt;NA&gt; Fema… 3-14 1 ## 6 Town A Tank filled by a truck tra… &lt;NA&gt; Male 0-2 1 ## 7 Town A Tank filled by a truck tra… &lt;NA&gt; Male 30-44 1 ## 8 Town B Direct from canal &lt;NA&gt; Male 3-14 1 ## 9 Town B Direct from canal &lt;NA&gt; Male 30-44 1 ## 10 Town B Other (specify) Untreated water w… Male 3-14 1 ## # ℹ 15 more rows 3.4.0.9 Pseudonymize indirect identifiers to limit re-identification risk (e.g. aggregate, withhold). With the five indirect identifiers noted above, we are far from our k-anonymity threshold… there are 25 combinations with k &lt; 5. We’re particularly interested in keeping variables sex and age_group, so let’s see what would happen if we withheld different combinations of the other identifiers. datadict::k_anonymity_counts(dat, c(&quot;sex&quot;, &quot;age_group&quot;), threshold = 5) ## # A tibble: 0 × 3 ## # ℹ 3 variables: sex &lt;chr&gt;, age_group &lt;fct&gt;, k &lt;int&gt; datadict::k_anonymity_counts(dat, c(&quot;sex&quot;, &quot;age_group&quot;, &quot;location&quot;), threshold = 5) ## # A tibble: 0 × 4 ## # ℹ 4 variables: sex &lt;chr&gt;, age_group &lt;fct&gt;, location &lt;chr&gt;, k &lt;int&gt; datadict::k_anonymity_counts(dat, c(&quot;sex&quot;, &quot;age_group&quot;, &quot;source_water&quot;), threshold = 5) ## # A tibble: 12 × 4 ## sex age_group source_water k ## &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; ## 1 Female 0-2 Direct from canal 1 ## 2 Male 30-44 Direct from canal 1 ## 3 Female 3-14 Direct from canal 2 ## 4 Female 45+ Tank filled by a truck transporting untreated water 2 ## 5 Male 0-2 Tank filled by a truck transporting untreated water 2 ## 6 Male 3-14 Direct from canal 2 ## 7 Male 3-14 Other (specify) 2 ## 8 Male 15-29 Other (specify) 2 ## 9 Male 30-44 Tank filled by a truck transporting untreated water 2 ## 10 Male 45+ Tank filled by a truck transporting untreated water 3 ## 11 Female 3-14 Tank filled by a truck transporting untreated water 4 ## 12 Male 15-29 Tank filled by a truck transporting untreated water 4 The variables source_water and source_water_other could potentially be aggregated into categories like “Treated water” and “Untreated water”. dat %&gt;% count(source_water, source_water_other) ## # A tibble: 5 × 3 ## source_water source_water_other n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 City water network piped to household &lt;NA&gt; 942 ## 2 Direct from canal &lt;NA&gt; 6 ## 3 Other (specify) Buying purified wat… 2 ## 4 Other (specify) Untreated water wel… 2 ## 5 Tank filled by a truck transporting untreated water &lt;NA&gt; 48 dat &lt;- dat %&gt;% mutate( water_source_agg = case_when( source_water == &quot;City water network piped to household&quot; ~ &quot;Source treated&quot;, source_water_other == &quot;Buying purified water&quot; ~ &quot;Source treated&quot;, !is.na(source_water) ~ &quot;Source untreated&quot;, TRUE ~ NA_character_ ) ) datadict::k_anonymity_counts(dat, c(&quot;sex&quot;, &quot;age_group&quot;, &quot;water_source_agg&quot;), threshold = 5) ## # A tibble: 4 × 4 ## sex age_group water_source_agg k ## &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; ## 1 Female 45+ Source untreated 2 ## 2 Male 0-2 Source untreated 2 ## 3 Male 30-44 Source untreated 3 ## 4 Male 45+ Source untreated 3 3.4.0.10 Repeat steps 8 and 9 until the given risk criterion is met. Even after aggregating the water source variables, we still do not meet our k-anonymity threshold if we also include sex and age_group. We therefore elect to withhold the water source variables. dat$water_source_agg &lt;- NULL # we can remove this one outright dat$source_water &lt;- NA_character_ dat$source_water_other &lt;- NA_character_ vars_withhold &lt;- c( &quot;source_water&quot;, &quot;source_water_other&quot; ) dict$status[dict$variable_name %in% vars_withhold] &lt;- &quot;withheld&quot; 3.4.0.11 Ensure that the final pseudonymized dataset and dictionary meet all data-sharing requirements. # check dictionary valid datadict::valid_dict(dict) ## [1] TRUE # check dataset corresponds with dictionary datadict::valid_data(dat, dict) ## Warning: - Columns present in `data` but not defined in `dict`: &quot;id&quot; ## [1] FALSE The variable id seems to be missing from the dictionary, so we’ll have to create a manual entry. dict &lt;- dict %&gt;% add_row( variable_name = &quot;id&quot;, short_label = &quot;Participant ID&quot;, type = &quot;Free text&quot;, choices = NA_character_, origin = &quot;original&quot;, status = &quot;shared&quot;, .before = 1 ) We’ll run the checks one final time, including a final check of our k-anonymity threshold. # check dictionary valid datadict::valid_dict(dict) ## [1] TRUE # check dataset corresponds with dictionary datadict::valid_data(dat, dict) ## [1] TRUE # check k-anonymity datadict::k_anonymity_counts(dat, c(&quot;sex&quot;, &quot;age_group&quot;, &quot;location&quot;), threshold = 5) ## # A tibble: 0 × 4 ## # ℹ 4 variables: sex &lt;chr&gt;, age_group &lt;fct&gt;, location &lt;chr&gt;, k &lt;int&gt; Finally, we’ll write the final, pseudonymized dataset and data dictionary for sharing. if (!dir.exists(here(&quot;output&quot;))) dir.create(here(&quot;output&quot;)) rio::export(dat, file = here(&quot;output/data_share.xlsx&quot;)) rio::export(dict, file = here(&quot;output/dict_share.xlsx&quot;)) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
